```html
<!DOCTYPE html>
<html lang="en" data-theme="cyber">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000308">
    <meta name="description" content="ElviraGenesis: The world's first GPU-cluster-compatible cybersecurity AI platform with capsule-based memory compression, ethical intelligence, and real-time multi-agent mutation for zero-day threat detection and forensic analysis.">
    <title>ElviraGenesis: Neuro Interface</title>
    <link href="/assets/fonts.css" rel="stylesheet">
    <link href="/assets/vis-network.min.css" rel="stylesheet">
    <script src="/assets/vis.min.js" defer></script>
    <script src="/assets/particles.min.js" defer></script>
    <style>
        :root {
            --primary-hue: 200;
            --secondary-hue: 280;
            --particle-color: hsl(180, 100%, 70%);
            --glass-bg: rgba(255, 255, 255, 0.06);
            --glass-border: rgba(255, 255, 255, 0.12);
            --neon-glow: 0 0 20px hsla(var(--primary-hue), 100%, 50%, 0.3);
            --void-black: #080808;
            --cyber-steel: #1a1a1a;
            --neon-cyan: #00f7ff;
            --neon-blue: #00f7ff;
            --neon-magenta: #ff00ff;
            --neon-green: #00ffcc;
            --neon-red: #ff3b30;
            --glow-blue: rgba(0, 247, 255, 0.3);
            --glow-magenta: rgba(255, 0, 255, 0.3);
            --glow-green: rgba(0, 255, 204, 0.3);
            --glow-red: rgba(255, 59, 48, 0.3);
            --slick-gray: #2a2a2a;
            --hud-white: rgba(240, 240, 240, 0.95);
            --accent-red: #FF3B30;
            --shadow: rgba(0, 0, 0, 0.85);
            --glow: rgba(0, 247, 255, 0.25);
            --border: rgba(0, 247, 255, 0.15);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'Exo 2', sans-serif;
            background: radial-gradient(ellipse at bottom, #0a0e1a 0%, #000308 100%);
            color: #fff;
        }

        .particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        #particles-js {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .hex-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 60 60"><path d="M15 5 L45 5 L55 25 L45 45 L15 45 L5 25 Z" stroke="rgba(0, 247, 255, 0.1)" fill="none" stroke-width="1"/></svg>');
            background-size: 60px 60px;
            background-repeat: repeat;
            opacity: 0.5;
            z-index: -1;
            pointer-events: none;
            animation: hexFade 15s ease-in-out infinite;
        }

        @keyframes hexFade {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.2; }
        }

        .terminal-line {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: linear-gradient(90deg, transparent, var(--neon-cyan), transparent);
            box-shadow: 0 0 60px var(--glow);
            animation: scan 6s infinite linear;
        }

        @keyframes scan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .frost-container {
            position: relative;
            max-width: 900px;
            margin: 2rem auto;
            padding: 2rem;
            display: grid;
            grid-template-rows: 1fr auto;
            gap: 1.5rem;
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            box-shadow: var(--neon-glow);
            border-radius: 1.5rem;
            transition: backdrop-filter 0.3s ease, box-shadow 0.3s ease;
        }

        .frost-container:hover {
            backdrop-filter: blur(50px) saturate(200%);
            box-shadow: 0 0 30px hsla(var(--primary-hue), 100%, 50%, 0.5);
        }

        .frost-container::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(45deg, 
                rgba(255,255,255,0.02) 0%, 
                rgba(255,255,255,0.01) 100%);
            z-index: -1;
        }

        .chat-log {
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            scroll-behavior: smooth;
            max-height: 400px;
            font-family: 'Source Code Pro', monospace;
            font-size: 1rem;
            color: var(--neon-green);
        }

        .message-bubble {
            position: relative;
            padding: 1.5rem;
            border-radius: 1.5rem;
            max-width: min(80%, 800px);
            background: var(--glass-bg);
            backdrop-filter: blur(25px);
            border: 1px solid var(--glass-border);
            transform: scale(0.98);
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1), backdrop-filter 0.3s ease;
            will-change: transform, backdrop-filter;
            animation: blurPulse 3s infinite ease-in-out;
        }

        .message-bubble:hover {
            transform: scale(1);
            backdrop-filter: blur(35px);
        }

        @keyframes blurPulse {
            0%, 100% { backdrop-filter: blur(25px); }
            50% { backdrop-filter: blur(30px); }
        }

        .message-bubble.user {
            align-self: flex-end;
            background: linear-gradient(135deg, 
                rgba(0, 200, 255, 0.15), 
                rgba(0, 100, 255, 0.25));
        }

        .message-bubble.ai {
            align-self: flex-start;
            background: linear-gradient(135deg, 
                rgba(255, 50, 255, 0.1), 
                rgba(150, 0, 255, 0.2));
        }

        .metrics-panel {
            padding: 1rem;
            background: var(--cyber-steel);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.9rem;
            color: var(--neon-green);
            margin-bottom: 1rem;
            transition: box-shadow 0.3s ease, backdrop-filter 0.3s ease;
        }

        .metrics-panel:hover {
            box-shadow: 0 0 20px var(--glow);
            backdrop-filter: blur(30px);
        }

        .query-history {
            padding: 1rem;
            background: var(--cyber-steel);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.9rem;
            color: var(--neon-green);
            margin-bottom: 1rem;
            transition: box-shadow 0.3s ease, backdrop-filter 0.3s ease;
        }

        .query-history:hover {
            box-shadow: 0 0 20px var(--glow);
            backdrop-filter: blur(30px);
        }

        .query-history ul {
            list-style: none;
            padding: 0;
        }

        .query-history li {
            margin-bottom: 0.5rem;
        }

        .input-group {
            position: relative;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 1rem;
            background: var(--glass-bg);
            border-radius: 1.5rem;
            backdrop-filter: blur(30px);
            transition: box-shadow 0.3s ease, backdrop-filter 0.3s ease;
        }

        .input-group:hover {
            box-shadow: 0 0 20px var(--glow);
            backdrop-filter: blur(40px);
        }

        .chat-input, .url-input {
            flex-grow: 1;
            padding: 1.25rem;
            border: none;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            color: #fff;
            font-size: clamp(1rem, 2vw, 1.25rem);
            transition: all 0.3s ease;
            min-width: 200px;
        }

        .chat-input:focus, .url-input:focus {
            outline: 2px solid var(--particle-color);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.2);
        }

        .file-input, .dataset-input {
            flex-grow: 1;
            padding: 1rem;
            color: var(--neon-green);
            min-width: 200px;
        }

        .send-button {
            padding: 1.25rem 2.5rem;
            border: none;
            border-radius: 1rem;
            background: linear-gradient(135deg, 
                rgba(0, 255, 255, 0.3), 
                rgba(0, 150, 255, 0.5));
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .send-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--glow);
        }

        /* Preloader Styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--void-black);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-in-out;
        }

        #preloader.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .preloader-hexagon {
            width: 60px;
            height: 60px;
            border: 4px solid var(--neon-cyan);
            border-radius: 10px;
            transform: rotate(45deg);
            animation: spin 2s infinite linear;
            box-shadow: 0 0 20px var(--glow);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        main {
            position: relative;
            z-index: 1;
            overflow-y: auto;
        }

        section {
            min-height: 100vh;
            padding: 8rem 4rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: all 0.5s ease-in-out;
        }

        #chat-section {
            min-height: auto;
            padding: 4rem;
        }

        h1 {
            font-family: 'Orbitron', 'Source Code Pro', monospace;
            font-size: 5.5rem;
@james
            color: var(--neon-cyan);
            text-shadow: 0 0 40px var(--glow);
            margin: 4rem 0;
            letter-spacing: -0.03em;
            animation: pulse 4s infinite;
            transition: all 0.5s ease-in-out;
        }

        h2 {
            font-family: 'Orbitron', 'Source Code Pro', monospace;
            font-size: 3.2rem;
            color: var(--neon-cyan);
            margin-bottom: 3rem;
            transition: all 0.5s ease-in-out;
        }

        p {
            max-width: 1200px;
            margin: 0 auto 2.5rem;
            font-size: 1.6rem;
            opacity: 0.9;
            transition: all 0.5s ease-in-out;
        }

        @media (max-width: 768px) {
            section {
                padding: 5rem 2rem;
            }
            #chat-section {
                padding: 2rem;
            }
            .frost-container {
                padding: 1rem;
            }
            .message-bubble {
                max-width: 90%;
                padding: 1.25rem;
            }
            .send-button {
                padding: 1rem 2rem;
            }
            h1 {
                font-size: 3.8rem;
            }
            h2 {
                font-size: 2.4rem;
            }
            p {
                font-size: 1.3rem;
                max-width: 100%;
            }
        }

        @media (max-width: 480px) {
            section {
                padding: 3rem 1rem;
            }
            #chat-section {
                padding: 1rem;
            }
            .message-bubble {
                max-width: 95%;
                padding: 1rem;
            }
            .chat-input, .url-input {
                font-size: 0.9rem;
            }
            .send-button {
                padding: 0.8rem 1.5rem;
                font-size: 0.9rem;
            }
            h1 {
                font-size: 1.8rem;
            }
            h2 {
                font-size: 1.4rem;
            }
            p {
                font-size: 1rem;
            }
        }

        /* Existing styles from previous index.html (abridged for brevity) */
        .grid { /* Existing grid styles */ }
        .card { /* Existing card styles */ }
        .badge { /* Existing badge styles */ }
        .cyber-button { /* Existing cyber-button styles */ }
        .accordion { /* Existing accordion styles */ }
        .feature-list { /* Existing feature-list styles */ }
        .llm-input { /* Existing llm-input styles */ }
        .llm-response { /* Existing llm-response styles */ }
        .api-demo { /* Existing api-demo styles */ }
        #tech-stack-diagram, #threat-detection-diagram, #ethical-validation-diagram, #neo4j-diagram {
            /* Existing diagram styles */
        }
        .cta-footer { /* Existing cta-footer styles */ }
    </style>
</head>
<body>
    <div id="preloader">
        <div class="preloader-hexagon"></div>
    </div>
    <canvas class="particle-canvas"></canvas>
    <div id="particles-js"></div>
    <div class="hex-overlay"></div>
    <div class="terminal-line"></div>

    <main>
        <!-- Chat Interface Section -->
        <section id="chat-section">
            <h2>ElviraGenesis Neuro Interface</h2>
            <div class="frost-container">
                <div class="chat-log" id="chatLog"></div>
                <div class="metrics-panel" id="metrics-panel"></div>
                <div class="query-history" id="query-history">
                    <h3>Query History</h3>
                    <ul id="history-list"></ul>
                </div>
                <div class="input-group">
                    <input type="text" class="chat-input" placeholder="Initiate neural interface..." id="chat-input">
                    <button class="send-button" onclick="sendQuery()">Transmit Query</button>
                    <input type="url" class="url-input" placeholder="Enter URL to learn from..." id="url-input">
                    <button class="send-button" onclick="sendUrl()">Transmit URL</button>
                    <input type="file" class="file-input" id="file-input" accept=".py,.java,.txt,.pdf,.png,.jpg,.wav,.mp3">
                    <button class="send-button" onclick="sendFile()">Upload File</button>
                    <input type="file" class="dataset-input" id="dataset-input" accept=".csv,.txt,.json,.zst,.zip">
                    <button class="send-button" onclick="sendDataset()">Upload Dataset</button>
                </div>
            </div>
        </section>

        <!-- Section 1: Introduction -->
        <section>
            <h1>ElviraGenesis: Pioneering Cybersecurity Excellence</h1>
            <p>ElviraGenesis is the world's first GPU-cluster-compatible cybersecurity AI platform, integrating capsule-based memory compression, DAG-verified ethical intelligence, and real-time multi-agent mutation. Designed for zero-day threat detection, forensic analysis, and regulatory-compliant governance, it operates on consumer-grade hardware with no speculative dependencies, ensuring a future where safety and innovation thrive.</p>
            <button class="cyber-button">Discover the Future</button>
        </section>

        <!-- Remaining sections unchanged (abridged for brevity) -->
        <section> <!-- Unique Selling Propositions --> </section>
        <section> <!-- Core Capabilities --> </section>
        <section> <!-- LLM Integration and GUI --> </section>
        <section> <!-- Model Training & Capsule Evolution --> </section>
        <section> <!-- Advanced Cybersecurity Modules --> </section>
        <section> <!-- Tech Stack --> </section>
        <section> <!-- Team Section --> </section>
        <section> <!-- Investment Opportunity --> </section>
        <section> <!-- Conclusion and Vision --> </section>
    </main>

    <footer class="cta-footer">
        <h1>Ready to Secure the Future?</h1>
        <p>Contact us for pilot deployment, investor discussions, or strategic partnership.</p>
        <button class="cyber-button">Contact Us</button>
    </footer>

    <script>
        // Environment Toggle
        const isLocal = window.location.hostname === 'localhost';
        const API_URL = isLocal ? 'http://localhost:8000/process_query' : '/api/process_query';
        const WS_URL = isLocal ? 'ws://localhost:8000/events' : 'wss://<api-id>.execute-api.us-east-1.amazonaws.com/prod/events';

        // WebSocket Connection
        const ws = new WebSocket(WS_URL);
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            const chatLog = document.getElementById('chatLog');
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ai`;
            bubble.innerHTML = `<strong>Session ${data.session_id}</strong>: ${data.unified_response}<br>` +
                Object.entries(data.model_responses || {}).map(([model, res]) => 
                    `<strong>${model}</strong>: ${res.response} (Ethical: ${res.ethical_score || 'N/A'})`
                ).join('<br>');
            chatLog.appendChild(bubble);
            scrollToBottom();
            saveHistory();

            // Update metrics panel
            if (data.metrics) {
                const metricsPanel = document.getElementById('metrics-panel');
                metricsPanel.innerHTML = `
                    <strong>Live Metrics</strong><br>
                    <span style="color: ${data.metrics.vram_usage_4070 > 10 ? 'var(--neon-red)' : 'var(--neon-green)'};">
                        VRAM Usage (4070): ${data.metrics.vram_usage_4070.toFixed(2)} GB
                    </span><br>
                    <span style="color: ${data.metrics.vram_usage_3060 > 10 ? 'var(--neon-red)' : 'var(--neon-green)'};">
                        VRAM Usage (3060): ${data.metrics.vram_usage_3060.toFixed(2)} GB
                    </span><br>
                    <span style="color: ${data.metrics.cpu_usage > 80 ? 'var(--neon-red)' : 'var(--neon-green)'};">
                        CPU Usage: ${data.metrics.cpu_usage.toFixed(2)}%
                    </span><br>
                    <span style="color: ${data.metrics.ram_usage > 80 ? 'var(--neon-red)' : 'var(--neon-green)'};">
                        RAM Usage: ${data.metrics.ram_usage.toFixed(2)}%
                    </span><br>
                    <span style="color: ${data.metrics.coherence_score < 0.7 ? 'var(--neon-red)' : 'var(--neon-green)'};">
                        Coherence Score: ${data.metrics.coherence_score.toFixed(4)}
                    </span><br>
                    <span style="color: ${data.metrics.ethical_score < 0.7 ? 'var(--neon-red)' : 'var(--neon-green)'};">
                        Ethical Score: ${data.metrics.ethical_score.toFixed(4)}
                    </span><br>
                    Response Time: ${data.metrics.response_time.toFixed(2)}s<br>
                    Capsule Count: ${data.metrics.capsule_count || 0}
                `;
            }

            // Update query history
            if (data.session_id && data.unified_response) {
                addToHistory(data.session_id, data.unified_response);
            }
        };

        async function sendQuery() {
            const query = document.getElementById('chat-input').value.trim();
            if (!query) return;
            addMessage(query, 'user');
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: query, user_id: 'web_user' })
                });
                const result = await response.json();
                ws.send(JSON.stringify({ command: 'process_query', data: query, user_id: 'web_user' }));
                // Sync history with backend
                await syncHistoryWithBackend(result.session_id, query, result.unified_response);
            } catch (e) {
                console.error('Query failed:', e);
                addMessage(`Error: ${e.message}`, 'ai');
            }
            document.getElementById('chat-input').value = '';
        }

        async function sendUrl() {
            const url = document.getElementById('url-input').value.trim();
            if (!url) return;
            addMessage(`URL: ${url}`, 'user');
            ws.send(JSON.stringify({ command: 'process_url', data: url, user_id: 'web_user' }));
            document.getElementById('url-input').value = '';
        }

        async function sendFile() {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];
            if (!file) return;
            addMessage(`File: ${file.name}`, 'user');
            const formData = new FormData();
            formData.append('file', file);
            formData.append('user_id', 'web_user');
            await fetch(isLocal ? 'http://localhost:8000/upload' : '/api/upload', {
                method: 'POST',
                body: formData
            });
            fileInput.value = '';
        }

        async function sendDataset() {
            const datasetInput = document.getElementById('dataset-input');
            const file = datasetInput.files[0];
            if (!file) return;
            addMessage(`Dataset: ${file.name}`, 'user');
            const formData = new FormData();
            formData.append('dataset', file);
            formData.append('user_id', 'web_user');
            await fetch(isLocal ? 'http://localhost:8000/upload_dataset' : '/api/upload_dataset', {
                method: 'POST',
                body: formData
            });
            datasetInput.value = '';
        }

        function addMessage(text, type) {
            const chatLog = document.getElementById('chatLog');
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${type}`;
            bubble.textContent = text;
            chatLog.appendChild(bubble);
            scrollToBottom();
            saveHistory();
        }

        function scrollToBottom() {
            const chatLog = document.getElementById('chatLog');
            chatLog.scrollTo({
                top: chatLog.scrollHeight,
                behavior: 'smooth'
            });
        }

        function addToHistory(sessionId, query) {
            const historyList = document.getElementById('history-list');
            const item = document.createElement('li');
            item.innerHTML = `<strong>${sessionId}</strong>: ${query}`;
            historyList.appendChild(item);
            saveHistory();
        }

        function saveHistory() {
            const messages = Array.from(document.getElementById('chatLog').children)
                .map(el => ({
                    text: el.textContent,
                    type: el.classList.contains('user') ? 'user' : 'ai'
                }));
            localStorage.setItem('neuroChatHistory', JSON.stringify(messages));
        }

        function loadHistory() {
            const history = JSON.parse(localStorage.getItem('neuroChatHistory') || '[]');
            history.forEach(msg => addMessage(msg.text, msg.type));
            // Load backend history in cloud mode
            if (!isLocal) {
                loadBackendHistory();
            }
        }

        async function syncHistoryWithBackend(sessionId, query, response) {
            if (!isLocal) {
                try {
                    await fetch(isLocal ? 'http://localhost:8000/sync_history' : '/api/sync_history', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: sessionId,
                            query: query,
                            response: response,
                            user_id: 'web_user'
                        })
                    });
                } catch (e) {
                    console.error('Failed to sync history:', e);
                }
            }
        }

        async function loadBackendHistory() {
            try {
                const response = await fetch(isLocal ? 'http://localhost:8000/get_history' : '/api/get_history', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                const history = await response.json();
                history.forEach(entry => {
                    addMessage(`Session ${entry.session_id}: ${entry.query}`, 'user');
                    addMessage(entry.response, 'ai');
                    addToHistory(entry.session_id, entry.response);
                });
            } catch (e) {
                console.error('Failed to load backend history:', e);
            }
        }

        // Quantum Particle System
        class QuantumParticles {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.particles = [];
                this.resize();
                this.init();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = window.innerWidth * devicePixelRatio;
                this.canvas.height = window.innerHeight * devicePixelRatio;
                this.ctx.scale(devicePixelRatio, devicePixelRatio);
            }

            init() {
                this.createParticles(150);
                this.animate();
            }

            createParticles(count) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: Math.random() * innerWidth,
                        y: Math.random() * innerHeight,
                        vx: (Math.random() - 0.5) * 0.3,
                        vy: (Math.random() - 0.5) * 0.3,
                        size: Math.random() * 2 + 1,
                        alpha: Math.random() * 0.3 + 0.2,
                        angle: Math.random() * Math.PI * 2
                    });
                }
            }

            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.angle += 0.02;
                    if (p.x < 0 || p.x > innerWidth) p.vx *= -1;
                    if (p.y < 0 || p.y > innerHeight) p.vy *= -1;
                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate(p.angle);
                    this.ctx.globalAlpha = p.alpha;
                    this.ctx.fillStyle = `hsl(180, 100%, 70%)`;
                    this.ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                    this.ctx.restore();
                });
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize particles.js and quantum particles
        document.addEventListener('DOMContentLoaded', function () {
            if (typeof particlesJS !== 'undefined') {
                particlesJS('particles-js', {
                    particles: {
                        number: { value: 300, density: { enable: true, value_area: 800 } },
                        color: { value: '#00f7ff' },
                        shape: { type: 'circle', stroke: { width: 0, color: '#000000' } },
                        opacity: { value: 0.8, random: true, anim: { enable: true, speed: 2, opacity_min: 0.3, sync: false } },
                        size: { value: 6, random: true, anim: { enable: true, speed: 25, size_min: 0.5, sync: false } },
                        line_linked: { enable: true, distance: 150, color: '#00f7ff', opacity: 0.4, width: 1.2 },
                        move: { enable: true, speed: 4, direction: 'none', random: false, straight: false, out_mode: 'out', bounce: false }
                    },
                    interactivity: {
                        detect_on: 'canvas',
                        events: { 
                            onhover: { enable: true, mode: 'repulse' }, 
                            onclick: { enable: true, mode: 'push' }, 
                            resize: true,
                            onQuery: { enable: true, mode: 'burst' } // Custom event for query submission
                        },
                        modes: { 
                            repulse: { distance: 150, duration: 0.5 }, 
                            push: { particles_nb: 5 },
                            burst: { particles_nb: 10, speed: 8 } // Burst effect on query
                        }
                    },
                    retina_detect: true
                });

                // Add custom event listener for query submission
                document.getElementById('chat-input').addEventListener('keypress', function(e) {
                    if (e.key === 'Enter' && this.value.trim()) {
                        particlesJS('particles-js').pJS.fn.vendors.interactivity.pushParticles(10, { speed: 8 });
                    }
                });
            } else {
                console.error('particlesJS is not defined.');
            }

            const particles = new QuantumParticles(document.querySelector('.particle-canvas'));
            loadHistory();

            // Initialize VisJS diagrams (existing code)
            drawTechStackDiagram();
            drawThreatDetectionDiagram();
            drawEthicalValidationDiagram();
            drawNeo4jDiagram();

            // Accordion functionality (existing code)
            document.querySelectorAll('.accordion-header').forEach(header => {
                header.addEventListener('click', () => {
                    const accordion = header.parentElement;
                    accordion.classList.toggle('active');
                });
            });
        });

        // Preloader Fade-Out
        window.addEventListener('load', function () {
            const preloader = document.getElementById('preloader');
            preloader.classList.add('fade-out');
        });

        // Existing VisJS diagram functions (unchanged)
        function drawTechStackDiagram() { /* Existing code from previous index.html */ }
        function drawThreatDetectionDiagram() { /* Existing code from previous index.html */ }
        function drawEthicalValidationDiagram() { /* Existing code from previous index.html */ }
        function drawNeo4jDiagram() { /* Existing code from previous index.html */ }

        // Existing LLM simulation functions (unchanged)
        async function callLLM() { /* Existing code from previous index.html */ }
        async function simulateOpenAICall(query) { /* Existing code */ }
        async function simulateLocalLLMCall(query) { /* Existing code */ }
        async function simulateGrokCall(query) { /* Existing code */ }
        async function simulateEthicalValidation(response) { /* Existing code */ }
        async function simulateAuditLog(query, response) { /* Existing code */ }
    </script>
</body>
</html>
```

### Backend Enhancements for Persistent History
To support backend-persisted chat history, I’ll add new endpoints to `web_server.py` for syncing and retrieving history.

<xaiArtifact artifact_id="edda9f70-8b55-49ef-8679-26279ee1836c" artifact_version_id="48e89b9e-e565-40d6-9c8d-89c5a87dbd39" title="web_server.py" contentType="text/python">
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
WebServer — ElviraGenesis-OMEGA
==============================
Purpose:
    Unified asyncio webserver for ElviraGenesis-OMEGA, handling WebSocket and REST
    endpoints for query processing, URL/file/dataset inputs, live metrics, and chat history.

Key Features:
    - Supports local mode (http://localhost:8000) and cloud mode (AWS Gateway).
    - Consolidated WebSocket/REST I/O handlers using FastAPI.
    - Real-time metrics broadcasting via WebSocket.
    - Health check endpoint for Kubernetes.
    - New endpoints for chat history sync and retrieval.

Author: ElviraGenesis AI Engineering
"""

import asyncio
import logging
import os
import uuid
from fastapi import FastAPI, WebSocket, UploadFile, File, HTTPException
from fastapi.responses import HTMLResponse
from starlette.websockets import WebSocketDisconnect
from pathlib import Path
from typing import Dict, Any, List
import json
import pynvml
import psutil
from modules.chat_box_backend import ChatBoxBackend
from modules.elvira_gui_interface import AI_SIGNALS

# Configuration
GENESIS_DIR = Path("/home/ben/BALI/cyber")
LOG_DIR = GENESIS_DIR / "infinity_output/logs"
LOG_DIR.mkdir(parents=True, exist_ok=True)

# Logging Setup
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s [%(levelname)s] [%(threadName)s] PID:%(pid)s %(message)s',
    handlers=[logging.FileHandler(LOG_DIR / f"web_server_{time.strftime('%Y%m%d_%H%M%S')}.log"), logging.StreamHandler()]
)
logger = logging.getLogger("WebServer")

app = FastAPI()
backend = ChatBoxBackend()
pynvml.nvmlInit()

# WebSocket clients
connected_clients = set()

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

@app.get("/")
async def get():
    with open("index.html", "r") as f:
        return HTMLResponse(f.read())

@app.post("/upload")
async def upload_file(file: UploadFile = File(...), user_id: str = "web_user"):
    try:
        file_path = os.path.join("/tmp", file.filename)
        with open(file_path, "wb") as f:
            f.write(await file.read())
        result = await backend.process_file(file_path, user_id)
        os.remove(file_path)
        return result
    except Exception as e:
        logger.error(f"File upload failed: {str(e)}", extra={"pid": os.getpid()})
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/upload_dataset")
async def upload_dataset(dataset: UploadFile = File(...), user_id: str = "web_user"):
    try:
        file_path = os.path.join("/tmp", dataset.filename)
        with open(file_path, "wb") as f:
            f.write(await file.read())
        result = await backend.process_dataset(file_path, user_id)
        os.remove(file_path)
        return result
    except Exception as e:
        logger.error(f"Dataset upload failed: {str(e)}", extra={"pid": os.getpid()})
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/process_query")
async def process_query(query: Dict[str, str]):
    try:
        result = await backend.process_query(query.get("data", ""), query.get("user_id", "web_user"))
        return result
    except Exception as e:
        logger.error(f"Query processing failed: {str(e)}", extra={"pid": os.getpid()})
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/process_url")
async def process_url(url: Dict[str, str]):
    try:
        result = await backend.process_url(url.get("data", ""), url.get("user_id", "web_user"))
        return result
    except Exception as e:
        logger.error(f"URL processing failed: {str(e)}", extra={"pid": os.getpid()})
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/sync_history")
async def sync_history(history: Dict[str, Any]):
    try:
        session_id = history.get("session_id")
        query = history.get("query")
        response = history.get("response")
        user_id = history.get("user_id", "web_user")
        capsule_data = {
            "hash": hashlib.sha3_512(json.dumps({"session_id": session_id, "query": query, "response": response}, sort_keys=True).encode()).hexdigest(),
            "compressed_data": [],  # Placeholder, could store vector if needed
            "metadata": {
                "session_id": session_id,
                "user_id": user_id,
                "query": query,
                "response": response,
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        await backend.capsule_bank.add_capsule(capsule_data, torch.randn(256, device=backend.device_compute), user_id=user_id)
        return {"status": "success"}
    except Exception as e:
        logger.error(f"History sync failed: {str(e)}", extra={"pid": os.getpid()})
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/get_history")
async def get_history(user_id: str = "web_user"):
    try:
        capsules = await backend.capsule_bank.get_capsules(user_id=user_id, limit=100)
        history = [
            {
                "session_id": capsule["metadata"]["session_id"],
                "query": capsule["metadata"]["query"],
                "response": capsule["metadata"]["response"]
            } for capsule in capsules if "query" in capsule["metadata"]
        ]
        return history
    except Exception as e:
        logger.error(f"History retrieval failed: {str(e)}", extra={"pid": os.getpid()})
        raise HTTPException(status_code=500, detail=str(e))

@app.websocket("/events")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    connected_clients.add(websocket)
    try:
        while True:
            data = await websocket.receive_json()
            command = data.get("command")
            user_id = data.get("user_id", "web_user")
            if command == "process_query":
                result = await backend.process_query(data["data"], user_id)
                await websocket.send_json(result)
            elif command == "process_url":
                result = await backend.process_url(data["data"], user_id)
                await websocket.send_json(result)
            elif command == "metrics":
                metrics = {
                    "vram_usage_4070": pynvml.nvmlDeviceGetMemoryInfo(pynvml.nvmlDeviceGetHandleByIndex(0)).used / 1e9,
                    "vram_usage_3060": pynvml.nvmlDeviceGetMemoryInfo(pynvml.nvmlDeviceGetHandleByIndex(1)).used / 1e9,
                    "cpu_usage": psutil.cpu_percent(),
                    "ram_usage": psutil.virtual_memory().percent
                }
                await websocket.send_json({"type": "metrics", "data": metrics})
    except WebSocketDisconnect:
        connected_clients.remove(websocket)
    except Exception as e:
        logger.error(f"WebSocket error: {str(e)}", extra={"pid": os.getpid()})

async def broadcast_metrics():
    """Broadcast live metrics to all connected WebSocket clients."""
    while True:
        try:
            metrics = {
                "vram_usage_4070": pynvml.nvmlDeviceGetMemoryInfo(pynvml.nvmlDeviceGetHandleByIndex(0)).used / 1e9,
                "vram_usage_3060": pynvml.nvmlDeviceGetMemoryInfo(pynvml.nvmlDeviceGetHandleByIndex(1)).used / 1e9,
                "cpu_usage": psutil.cpu_percent(),
                "ram_usage": psutil.virtual_memory().percent
            }
            for client in connected_clients:
                await client.send_json({"type": "metrics", "data": metrics})
            await asyncio.sleep(5)
        except Exception as e:
            logger.error(f"Metrics broadcast failed: {str(e)}", extra={"pid": os.getpid()})

if __name__ == "__main__":
    import uvicorn
    asyncio.create_task(broadcast_metrics())
    uvicorn.run(app, host="0.0.0.0", port=8000)
