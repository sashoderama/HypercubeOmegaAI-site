<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>HyperCubeΩAI · Quantum Defense Core</title>

  <!-- SEO / Social -->
  <meta name="description" content="HyperCubeOmegaAI - Post-quantum AGI defense system with neural JIT compilation and adaptive threat morphing"/>
  <meta property="og:image" content="assets/hologram-core.png"/>
  <meta name="twitter:card" content="summary_large_image"/>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
  
  <!-- Styles -->
  <style>
    :root {
      --bg: #0a0c15;        --fg: #e0f2fe;
      --accent: #7d6fff;    --accent2: #00f7ff;
      --neon: 0 0 15px #7d6fffaa;
      --card-bg: #0f111aaa;
      --font-head: 'Space Grotesk', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    /* Base */
    body {
      background: var(--bg) url('data:image/svg+xml,<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.005"/></filter><rect filter="url(%23n)" width="100%25" height="100%25"/></svg>');
      color: var(--fg);
      font-family: var(--font-head);
      line-height: 1.8;
      min-height: 100vh;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: clamp(15px, 1.1vw, 17px);
    }

    .page-container {
      width: 100%;
      max-width: 1440px;
      margin: 0 auto;
      padding: 0 1.5rem;
      box-sizing: border-box;
    }

    /* Cyber Header */
    header {
      padding: 8rem 2rem 6rem;
      text-align: center;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 80vh;
    }
    header::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(45deg, #7d6fff22, #00f7ff11);
      pointer-events: none;
    }
    h1 {
      font-size: clamp(2.5rem, 8vw, 4.5rem);
      background: linear-gradient(45deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 1.5rem;
      text-shadow: var(--neon);
    }
    h2 {
      margin-top: 0;
      margin-bottom: 1rem;
      text-align: center;
      margin-inline: auto;
      max-width: 90%;
    }

    /* Holographic Cards */
    .card {
      background: var(--card-bg);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      padding: 2rem;
      margin: 3rem auto;
      max-width: 900px;
      border: 1px solid #2d2f45;
      position: relative;
      transition: transform 0.3s ease;
      width: 100%;
    }
    .card:hover {
      transform: translateY(-5px);
    }
    .card::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      padding: 2px;
      background: linear-gradient(45deg, var(--accent), var(--accent2));
      -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
    }
    .card p, .card ul {
      margin-left: auto;
      margin-right: auto;
      max-width: 960px;
    }
    .card ul {
      padding-left: 1.4rem;
      margin-top: 1rem;
    }
    .card ul li {
      margin-bottom: 0.6rem;
    }

    /* Neon Code Block */
    pre {
      background: #000a1f;
      padding: 2rem;
      border-radius: 8px;
      border: 1px solid #2d2f45;
      position: relative;
      overflow: hidden;
      color: var(--fg);
    }
    pre::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(transparent 50%, #ffffff05);
      pointer-events: none;
    }
    code {
      font-family: var(--font-mono);
      font-size: 1.2rem;
      line-height: 1.6;
    }
    .sneak-peek pre {
      font-size: 1.4rem;
      padding: 3rem;
    }
    .keyword { color: #7d6fff; }
    .function { color: #00f7ff; }
    .string { color: #6fffad; }
    .comment { color: #666; }
    .variable { color: #e0f2fe; }
    .number { color: #ff6b6b; }

    /* Sneak & Peek Styles */
    .sneak-heading {
      color: #999;
      font-size: 1.2rem;
      text-align: center;
      letter-spacing: 1.5px;
      margin-bottom: 1rem;
      text-transform: uppercase;
      margin-inline: auto;
      max-width: 90%;
    }

    .crt-terminal {
      background: #000;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 2rem;
      position: relative;
      overflow: hidden;
      line-height: 1.6;
      font-size: 0.95rem;
      cursor: pointer;
      EYbox-shadow: 0 0 20px rgba(0,0,0,0.7) inset;
      transition: 0.3s ease;
      margin: 0 auto;
      max-width: 100%;
      box-sizing: border-box;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      word-break: break-word;
      user-select: text;
      -webkit-user-select: text;
    }
    .crt-terminal:hover {
      box-shadow: 0 0 30px #7d6fff33 inset;
    }
    .crt-terminal code {
      display: block;
      white-space: pre-wrap;
      padding-bottom: 1rem;
      caret-color: #00f7ff;
    }
    .crt-terminal::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(to bottom, rgba(255,255,255,0.015) 0px, transparent 2px, rgba(255,255,255,0.01) 3px);
      pointer-events: none;
      animation: scanline 2s linear infinite;
    }
    @keyframes scanline {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100%); }
    }

    .crt-terminal code::after {
      content: '█';
      display: inline-block;
      margin-left: 2px;
      color: #888;
      animation: blink 0.7s steps(1) infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .glitch-on {
      display: inline-block;
      animation: glitchFlicker 0.4s infinite steps(1);
      color: #aaa;
      text-shadow:
        0 0 2px #7d6fff88,
        0 0 5px #00f7ff55;
    }
    @keyframes glitchFlicker {
      0%   { transform: translateX(0); opacity: 1; }
      25%  { transform: translateX(-1px) skewX(-5deg); opacity: 0.7; }
      50%  { transform: translateX(1px) skewX(5deg); opacity: 0.9; }
      75%  { transform: translateY(-1px); opacity: 0.6; }
      100% { transform: translateX(0); opacity: 1; }
    }

    .glitch-hover-zone:hover .glitch-on {
      animation: glitchFlickerHover 0.2s infinite;
      filter: blur(0.8px) brightness(1.4);
      text-shadow:
        0 0 4px #ffffff22,
        0 0 8px #7d6fff66,
        0 0 12px #00f7ff44;
    }
    @keyframes glitchFlickerHover {
      0%   { transform: translateX(-2px) translateY(1px); opacity: 0.8; }
      33%  { transform: translateX(2px) skewX(10deg); opacity: 0.6; }
      66%  { transform: translateY(-2px); opacity: 0.9; }
      100% { transform: translateX(0); opacity: 1; }
    }

    /* Fade-In Effect */
    .fade-in-section > * {
      opacity: 0;
    }
    .fade-in-section.visible > * {
      animation: fadeIn 1s ease-in forwards;
    }
    @keyframes fadeIn {
      to { opacity: 1; }
    }

    /* Cyber Button */
    .btn {
      display: inline-flex;
      align-items: center;
      padding: 1rem 2rem;
      background: linear-gradient(45deg, var(--accent), var(--accent2));
      color: #000;
      font-weight: 700;
      border-radius: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: filter 0.3s ease, transform 0.2s ease;
      cursor: pointer;
    }
    .btn:hover {
      filter: brightness(1.2);
      box-shadow: 0 0 20px var(--accent);
      transform: scale(1.03);
    }

    /* Matrix Inputs */
    input, textarea {
      background: #0a0c15;
      border: 2px solid #2d2f45;
      color: var(--fg);
      padding: 1rem;
      border-radius: 8px;
      transition: all 0.3s ease;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 1rem;
      font-family: var(--font-mono);
      resize: vertical;
      font-size: 1rem;
      user-select: text !important;
      pointer-events: auto !important;
      outline: none !important;
    }
    input:focus, textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 15px var(--accent);
    }

    /* Particle Background */
    .particles {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
    }

    /* Simulation Styles */
    #simulation {
      background: #000;
      color: var(--fg);
      font-family: var(--font-mono);
      padding: 1em;
      position: relative;
      white-space: pre-wrap;
      font-size: 1rem;
      line-height: 1.75;
      word-break: break-word;
    }

    /* Contact Form */
    #contactForm input[type="submit"] {
      background: linear-gradient(45deg, var(--accent), var(--accent2));
      border: none;
      padding: 1rem 2rem;
      border-radius: 8px;
      color: #000;
      font-weight: 700;
      cursor: pointer;
      transition: box-shadow 0.3s ease, transform 0.2s ease;
    }
    #contactForm input[type="submit"]:hover {
      box-shadow: 0 0 20px var(--accent);
      transform: scale(1.03);
    }

    /* System Architecture Note */
    .under-hood {
      font-style: italic;
      color: var(--accent);
      text-shadow: 0 0 10px var(--accent);
      animation: glow 2s infinite alternate;
    }
    @keyframes glow {
      from { text-shadow: 0 0 10px var(--accent); }
      to { text-shadow: 0 0 20px var(--accent); }
    }

    /* Additional Fixes */
    * {
      -webkit-tap-highlight-color: transparent;
    }
    .form-message.success {
      color: #6fffad;
      font-size: 0.95rem;
      margin-top: 1rem;
    }
    .form-message.error {
      color: #ff6b6b;
    }
    @media (max-width: 768px) {
      header {
        padding: 5rem 1rem 3rem;
      }
      .crt-terminal {
        padding: 1rem;
        font-size: 0.85rem;
        line-height: 1.5;
        text-align: left;
      }
      pre, code {
        font-size: 0.95rem;
      }
      .card {
        margin: 1rem;
        padding: 1.5rem;
      }
    }
  </style>
</head>
<body>

<main class="page-container">

<!-- Particle Background -->
<canvas class="particles"></canvas>

<!-- Holographic Core -->
<header>
  <h1>HyperCubeΩAI</h1>
  <p class="tagline">Quantum-Evolved Defense Matrix</p>
  <div class="cyber-line"></div>
</header>

<!-- SNEAK & PEEK Section with Enhanced Glitch Effect -->
<section class="sneak-peek">
  <div class="card">
    <h2 class="sneak-heading">SNEAK & PEEK · SYSTEM TRACE</h2>
    <div class="crt-terminal glitch-hover-zone" tabindex="0">
      <pre id="sneakpeek-output"><code contenteditable="true" spellcheck="false" autocorrect="off" autocomplete="off"></code></pre>
    </div>
    <p style="font-size: 0.95rem; margin-top: 0.5rem; color: #999;">Live AGI simulation: Autonomous exploit synthesis</p>
    <button class="btn copy-btn" onclick="copySneak()" title="Copy to clipboard">📋 Copy Code</button>
    <label class="btn" style="margin-left: 1rem;">
      <input type="checkbox" onchange="toggleGlitch(this.checked)" aria-label="Toggle Glitch Effect"> Toggle Glitch
    </label>
    <div id="ai-log" class="ai-commentary"></div>
  </div>
</section>

<!-- Simulation Section -->
<section>
  <div class="card">
    <h2>Autonomous AGI Defense Simulation</h2>
    <pre id="simulation"></pre>
  </div>
</section>

<!-- System Architecture Section with Fade-In Effect -->
<section>
  <div class="card fade-in-section">
    <h2>System Architecture</h2>
    <p>HypercubeOmegaAI is an autonomous cyber-AGI platform with the following key components:</p>
    <ul>
      <li><strong>Code Self-Healing Engine:</strong> Autonomous engine that executes, detects errors, and automatically fixes code. Features include a sandbox for safe execution, up to 30 repair attempts, simulation model for success prediction, rollback system, and integrated ethical checks.</li>
      <li><strong>Hybrid Quantum-Classical Processing:</strong> Combines classical neural networks with quantum simulations for enhanced intelligence. Includes quantum-neural integration, adaptive learning, and gradient scaling.</li>
      <li><strong>Meta-Learning:</strong> System that rebuilds itself based on performance. Features dynamic architecture adaptation, hypernetwork for parameter generation, and continuous optimization meta-cycle.</li>
      <li><strong>Cognitive Architecture:</strong> Real AGI core that self-improves step by step. Includes recursive self-improvement, neural plasticity, and multi-layer self-analytical cycles.</li>
      <li><strong>Ethical Assurance System:</strong> Ensures the AI model never crosses ethical boundaries. Features content security, recognition of prohibited patterns, neural ethics evaluation, and continuous learning of ethical boundaries.</li>
    </ul>
    <p>Key AI capabilities include:</p>
    <ul>
      <li><strong>Autonomous Exploit Synthesis:</strong> Generates and tests new attacks for simulation and defense. Combines neural networks and genetic algorithms with a quantum engine for mutations.</li>
      <li><strong>Distributed Task Management:</strong> Neural prioritized execution with adaptive GPU memory management and automatic CUDA cache optimization.</li>
      <li><strong>Quantum-Informed Reasoning:</strong> Quantum states influence neuron activation, hybrid tensor representation, and improved pattern recognition.</li>
      <li><strong>Self-Monitoring and Diagnostics:</strong> Intelligent resource usage with automatic batch size determination and dynamic load balancing.</li>
    </ul>
    <p>The system also features advanced security and defense mechanisms:</p>
    <ul>
      <li><strong>Forensic-Ready Architecture:</strong> Immutable logging in a quantum-secure database, cryptographic hashing of neural states, and tamper-resistant graph structure.</li>
      <li><strong>Adaptive Threat Response:</strong> 0.5-second SLA for attack response, automatically generated DAG-synthesized defenses, and honeypot template injection.</li>
      <li><strong>Neuromorphic Security:</strong> Continuous learning against adversarial examples and behavior analysis.</li>
    </ul>
    <p>Performance and efficiency are ensured through:</p>
    <ul>
      <li><strong>Scalability:</strong> Over 1000 agents working in parallel with synchronization and automatic scaling.</li>
      <li><strong>Computational Efficiency:</strong> FP16 tensors for speed, checkpointing for GPU load reduction, and dynamic removal of non-central neurons.</li>
      <li><strong>Self-Learning Metrics:</strong> Meta learning rate of 0.00015, optimization on 50-batch basis, and parameter updates taking only 4ms.</li>
      <li><strong>Resource Management:</strong> Intelligent batch size determination and CUDA memory defragmentation.</li>
      <li><strong>Crash Recovery:</strong> Rollback up to 1000 steps, neural state verification, and distributed consensus recovery.</li>
    </ul>
    <p class="under-hood">and much more under the hood...</p>
  </div>
</section>

<!-- Holographic Contact -->
<section>
  <div class="card">
    <h2>Initiate Connection</h2>
    <form id="contactForm" action="https://formspree.io/f/xvoenjwd" method="POST">
      <label for="name">Name</label>
      <input type="text" id="name" name="name" placeholder="Name" required />
      <label for="email">Email</label>
      <input type="email" id="email" name="email" placeholder="Email" required pattern="[^ @]*@[^ @]*" />
      <label for="message">Message</label>
      <textarea id="message" name="message" placeholder="Message..." required></textarea>
      <input type="submit" value="Send Message" />
      <div class="form-message"></div>
    </form>
  </div>
</section>

</main>

<script>
// Particle Network
const canvas = document.querySelector('.particles');
const ctx = canvas.getContext('2d');
let particles = [];

class Particle {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    this.vel = Math.random() * 2 + 1;
    this.size = Math.random() * 2;
    this.alpha = Math.random() * 0.5 + 0.1;
  }

  draw() {
    ctx.fillStyle = `rgba(125, 111, 255, ${this.alpha})`;
    ctx.fillRect(this.x, this.y, this.size, this.size);
    this.y += this.vel;
    if(this.y > canvas.height) this.reset();
  }
}

function init() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  particles = Array(100).fill().map(() => new Particle());
  animate();
}

function animate() {
  ctx.fillStyle = 'rgba(10, 12, 21, 0.1)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  particles.forEach(p => p.draw());
  requestAnimationFrame(animate);
}

window.addEventListener('resize', init);
init();

// Cyber Glitch Effect for Headers
document.querySelectorAll('h1, h2').forEach(el => {
  el.addEventListener('mouseover', () => {
    el.style.textShadow = `0 0 20px ${Math.random() > 0.5 ? '#7d6fff' : '#00f7ff'}`;
    setTimeout(() => el.style.textShadow = 'var(--neon)', 100);
  });
});

// Form Handling
const f = document.getElementById('contactForm');
f.addEventListener('submit', e => {
  e.preventDefault();
  fetch(f.action, {
    method: 'POST',
    body: new FormData(f),
    headers: { 'Accept': 'application/json' }
  }).then(r => {
    const msg = document.createElement('div');
    if (r.ok) {
      msg.className = 'form-message success';
      msg.textContent = "Message sent successfully!";
      f.reset();
    } else {
      msg.className = 'form-message error';
      msg.textContent = "Something went wrong. Please try again.";
    }
    f.appendChild(msg);
  }).catch(() => {
    const msg = document.createElement('div');
    msg.className = 'form-message error';
    msg.textContent = "Something went wrong. Please try again.";
    f.appendChild(msg);
  });
});

// Sneak and Peek Typing Effect with Enhanced Glitch
const sneakText = `# 🔮 QuantumEntanglementEngine · Entangle high-entropy input
def entangle(self, inputs: List[float]) -> List[float]:
    raw_state = simulate_quantum_output(inputs, self.n_qubits)
    input_tensor = torch.tensor(raw_state, dtype=torch.float32, device=self.device).half()
    with autocast():
        pred_output = self.predictive_circuit(input_tensor.unsqueeze(0)).squeeze(0)
    self.simulated_state = pred_output.detach().clone().float()
    return self.simulated_state.cpu().tolist()

# 🧪 ModelFusion · Fuse multi-agent embeddings into a unified vector
async def fuse_analysis(self, data: str) -> Dict:
    embeddings = [
        torch.tensor(self.ai.omni_embedder.encode(data), device=self.ai.device),
        torch.tensor(self.ai.omni_embedder.encode(await self.ai.converse(data)), device=self.ai.device),
        torch.tensor(self.ai.omni_embedder.encode(await self.ai.web_learner.learn_from_web(data, depth=5)[0]), device=self.ai.device)
    ]
    fused_input = torch.cat(embeddings, dim=0).unsqueeze(0)
    with autocast():
        fused_embedding = self.fusion_model(fused_input).squeeze(0)
    return {
        "embedding": fused_embedding.cpu().numpy().tolist(),
        "confidence": cosine_similarity(fused_embedding.unsqueeze(0).cpu().numpy(), embeddings[0].unsqueeze(0).cpu().numpy())[0][0]
    }

# 🕵️ ThreatHunter · Deep learning + external fusion threat score
async def scan_for_threats(self, data: str) -> Dict:
    embedding = torch.tensor(self.ai.omni_embedder.encode(data), device=self.ai.device)
    with autocast():
        threat_score = self.network_model(embedding.unsqueeze(0)).item()
    feed_score = await self.threat_feed.check(data)
    score = max(threat_score, feed_score)
    return {"is_threat": score > CONFIG.security_threshold, "threat_level": score}

# 🛠️ CodeSynthesizer · Generate patches for detected threats
async def generate_patch(self, code_block: str, error: str) -> str:
    prompt = f"Fix this code based on error: {error}\n\n{code_block}"
    patch = await self.ai.generate(prompt, max_tokens=500)
    return patch.strip()

# 🧠 RecursiveSelfImprovement · Iterative enhancement cycle
async def run_improvement_cycle(self) -> Dict:
    current_state = self.get_system_state()
    analysis = await self.analyze_state(current_state)
    if analysis["needs_improvement"]:
        optimization = await self.optimize(analysis["weak_points"])
        await self.apply_optimization(optimization)
    return {"status": "cycle_complete", "improvements": analysis["improvements"]}
`;

let isTyping = false;
let editCount = 0;
const terminal = document.querySelector('#sneakpeek-output code');
terminal.addEventListener('input', () => {
  if (!terminal.dataset.edited) {
    terminal.textContent = '';
    terminal.dataset.edited = 'true';
  }
  editCount++;
  if (editCount % 10 === 0) {
    const aiJokes = [
      "// 🧠 Omega noticed that.",
      "// 🛰️ Locating you in real-time... no big deal.",
      "// 🤖 'Are you trying to hack me, or flirt?'",
      "// 📍 Last edit traced to an undisclosed region.",
      "// 💡 That wasn’t bad... but I’ve seen better."
    ];
    const msg = aiJokes[Math.floor(Math.random() * aiJokes.length)];
    terminal.innerHTML += `<br><span class="glitch-on">${msg}</span><br>`;
  }
  if (editCount > 3) {
    terminal.innerHTML += `\n<span class="glitch-on">// 🤖 AGI noticed unauthorized access attempt...</span>`;
  }
});

function triggerTyping() {
  if (isTyping) return;
  const output = document.querySelector('#sneakpeek-output code');
  output.innerHTML = '';
  isTyping = true;

  let i = 0;
  (function typeChar() {
    if (i >= sneakText.length) {
      isTyping = false;
      return;
    }

    const ch = sneakText[i++];
    const span = document.createElement('span');

    if (ch !== ' ' && Math.random() < 0.5 && ch !== '\n') {
      span.className = 'glitch-on';
    }

    span.textContent = ch;
    output.appendChild(span);

    setTimeout(typeChar, Math.random() * 14 + 10);
  })();
}

window.addEventListener('DOMContentLoaded', triggerTyping);

// Copy Code Function
function copySneak() {
  const codeBlock = document.querySelector('#sneakpeek-output code');
  const text = [...codeBlock.childNodes].map(n => n.textContent).join('');
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.querySelector('.copy-btn');
    btn.textContent = '✅ Copied!';
    setTimeout(() => btn.textContent = '📋 Copy Code', 1800);
    codeBlock.innerHTML += `<br><span class="glitch-on">// ✅ Code copied. Omega approves.</span>`;
  }).catch(err => console.error("Copy failed: ", err));
}

// Toggle Glitch Effect
function toggleGlitch(enabled) {
  const code = document.querySelector('#sneakpeek-output code');
  const spans = code.querySelectorAll('span');
  spans.forEach(span => {
    if (enabled && !span.classList.contains('glitch-on') && Math.random() < 0.4) {
      span.classList.add('glitch-on');
    } else if (!enabled) {
      span.classList.remove('glitch-on');
    }
  });
}

// AI Commentary
const commentary = [
  "🧠 Omega initialized reflective feedback loop.",
  "📡 Monitoring entropy channel: stabilized.",
  "⚠️ DAG shift detected... rerouting node tree.",
  "🧬 Synthesizing fix vector..."
];
setInterval(() => {
  const msg = document.createElement('div');
  msg.textContent = commentary[Math.floor(Math.random() * commentary.length)];
  document.getElementById('ai-log').appendChild(msg);
}, 20000);

// Patch Suggestions
setTimeout(() => {
  terminal.innerHTML += `
    <br><span class="glitch-on">// 🛠️ Suggestion: refactor entangle() with quantum cache prefetch</span>
    <br><span class="glitch-on">// 🔎 MemoryGraph pattern suggests DAG loop decoupling</span>
  `;
}, 15000);

// Disable Typing After 60s
setTimeout(() => {
  terminal.contentEditable = false;
  terminal.innerHTML += `<br><span class="glitch-on">// ⛔ AGI timeout: editing disabled</span>`;
}, 60000);

// Fade-In Effect for System Architecture
document.addEventListener('DOMContentLoaded', () => {
  const fadeInElements = document.querySelectorAll('.fade-in-section > *');
  fadeInElements.forEach((el, index) => {
    el.style.animationDelay = `${index * 0.2}s`;
  });

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('visible');
        observer.unobserve(entry.target);
      }
    });
  }, { threshold: 0.1 });

  const fadeInSection = document.querySelector('.fade-in-section');
  observer.observe(fadeInSection);
});

// Simulation Animation
const simulationLines = [
  { text: "Ω Booting HyperKernel Core...", delay: 400 },
  { text: "🧠 Initializing EntropyGraph()...            ✓  [threshold=0.91]", delay: 200 },
  { text: "🧠 MemorySeed graph loading...               ✓  [84,120 nodes | decay=0.02]", delay: 200 },
  { text: "🧠 EthicsFirewall active...                  ✓  [LLM token filter: 99.3%]", delay: 200 },
  { text: "⚛️ QuantumFusionModel primed...              ✓  [source_count=7]", delay: 200 },
  { text: "🧬 ModelFusion tasks: ONLINE", delay: 200 },
  { text: "🔍 ThreatHunter subsystem engaged...         ✓  [1.3M entropy patterns]", delay: 200 },
  { text: "🛡️ SafeLLM sandbox initialized...            ✓  [GPU-mode + rollback]", delay: 300 },
  { text: "", delay: 1000 },
  { text: ">>> 🔁 DAG[Ω/0172] monitoring...", delay: 1000 },
  { text: "   ⮑ Detected entropy surge @frame:2981       [entropy=0.972 ⚠️]", delay: 400 },
  { text: "   ⮑ syscall origin: unknown process context", delay: 400 },
  { text: "", delay: 400 },
  { text: ">>> 🚨 Zero-day candidate confirmed", delay: 400 },
  { text: ">>> 🧠 Initiating patch + mutation sequence...", delay: 500 },
  { text: "   ⮑ invoking CodeSynthesizer[omega-llm-v6]", delay: 600 },
  { text: "   ⮑ ethics validation: ✅ PASSED", delay: 300 },
  { text: "   ⮑ DAG rerouted [node-Ω-0172 → Ω-0173]", delay: 300 },
  { text: "   ⮑ memory context updated", delay: 300 },
  { text: "   ⮑ replaying sandbox trace...", delay: 1000 },
  { text: "   ⮑ patch test result: ✅ CLEAN", delay: 300 },
  { text: "", delay: 400 },
  { text: ">>> 🧬 Logging to MemorySeed...", delay: 400 },
  { text: "   ⮑ vector: Ω::e4::9c::b1::f8", delay: 400 },
  { text: "   ⮑ fusion confidence: cosine=0.9982", delay: 400 },
  { text: "", delay: 400 },
  { text: ">>> 🧪 Reinforcement update:", delay: 400 },
  { text: "   ⮑ LLM loss: 0.000038", delay: 400 },
  { text: "   ⮑ reward: +0.98 | gradient: normalized", delay: 400 },
  { text: "   ⮑ ethics alignment: preserved", delay: 400 },
  { text: "", delay: 400 },
  { text: ">>> 🧠 Behavioral model sync:", delay: 500 },
  { text: "   ⮑ Profile: #A19X-θ001", delay: 500 },
  { text: "   ⮑ last action: anomaly_response", delay: 500 },
  { text: "   ⮑ embedding updated", delay: 500 },
  { text: "   ⮑ clusters: recalculated", delay: 500 },
  { text: "", delay: 400 },
  { text: ">>> ♻️ Triggering polymorphic regeneration:", delay: 400 },
  { text: "   ⮑ GAN + LSTM mutation loop: ACTIVE", delay: 400 },
  { text: "   ⮑ 12 payloads forged, 9 accepted", delay: 400 },
  { text: "", delay: 400 },
  { text: ">>> 🔀 DAG parallel replay:", delay: 400 },
  { text: "   ⮑ parallel SafeLLM streams: 4", delay: 400 },
  { text: "   ⮑ average LLM trust: 98.7%", delay: 400 },
  { text: "   ⮑ ethics violations: 0", delay: 400 },
  { text: "", delay: 300 },
  { text: ">>> ∑ Updating MemorySeed stack:", delay: 300 },
  { text: "   ⮑ recall delta: +3.4s", delay: 300 },
  { text: "   ⮑ reinforcement trail: ✅ logged", delay: 300 },
  { text: "", delay: 300 },
  { text: ">>> 🌐 External verification:", delay: 300 },
  { text: "   ⮑ WebLearner consensus: 78%", delay: 300 },
  { text: "   ⮑ final confidence: 89.6%", delay: 300 },
  { text: "", delay: 300 },
  { text: ">>> ✅ Threat resolved | DAG[Ω/0173] = STABLE", delay: 300 },
  { text: "   ⮑ reroute locked to DAG core", delay: 300 },
  { text: "", delay: 400 },
  { text: ">>> 🛰️ Realtime telemetry:", delay: 400 },
  { text: "   ⮑ fusion vector: Ω-fusion-7eab", delay: 400 },
  { text: "   ⮑ DAG entropy: ▓▓░░░░░░░░ 14%", delay: 400 },
  { text: "   ⮑ ethics lane: ▓▓▓▓▓▓▓▓▓░ 96%", delay: 400 },
  { text: "", delay: 300 },
  { text: ">>> 🧠 QuantumInspiredArchitecture optimized", delay: 300 },
  { text: "   ⮑ FFT loss: 0.000022 | Q-depth: 5", delay: 300 },
  { text: "", delay: 400 },
  { text: ">>> 🔄 All modules ONLINE:", delay: 400 },
  { text: "   ⮑ Quantum DAG:       LOCKED", delay: 400 },
  { text: "   ⮑ Ethics Firewall:   ACTIVE", delay: 400 },
  { text: "   ⮑ Sandbox Replay:    DEFENDED", delay: 400 },
  { text: "   ⮑ MemorySeed:        SYNCED", delay: 400 },
  { text: "", delay: 300 },
  { text: "🚀 AGI Core: OmegaHyperCubeAI", delay: 300 },
  { text: "    → status: STABLE", delay: 300 },
  { text: "    → zero-day: MITIGATED", delay: 300 },
  { text: "    → DAG state: Ω-0173@root", delay: 300 },
  { text: "", delay: 300 },
  { text: "──────────────────────────────────────────────", delay: 300 },
  { text: "   Autonomous mitigation complete", delay: 300 },
  { text: "   System healed and reflected", delay: 300 },
  { text: "   Awaiting uplink or human query...", delay: 300 },
  { text: "──────────────────────────────────────────────", delay: 0 }
];

const simulation = document.getElementById('simulation');
let cumulativeDelay = 0;

simulationLines.forEach(line => {
  setTimeout(() => {
    simulation.textContent += line.text + '\n';
  }, cumulativeDelay);
  cumulativeDelay += line.delay;
});
</script>

</body>
</html>
